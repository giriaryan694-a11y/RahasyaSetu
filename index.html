<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>RahasyaSetu — Stego Client (Made by Aryan Giri)</title>
  <style>
    :root{ --bg:#0b0f12; --panel:#071018; --accent:#00ffa3; --muted:#7f8c8d; --glass: rgba(255,255,255,0.03); --mono: 'SFMono-Regular', Menlo, Monaco, 'Roboto Mono', monospace; }
    *{box-sizing:border-box}
    body{margin:0; min-height:100vh; background: linear-gradient(180deg,#020305 0%, #071018 60%); color:#dfeff0; font-family:Inter, system-ui, Arial, sans-serif; display:flex; align-items:center; justify-content:center; padding:28px}
    .card{width:980px; max-width:96vw; background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border-radius:14px; padding:22px; box-shadow: 0 10px 30px rgba(2,6,10,0.6); border:1px solid rgba(0,255,163,0.06)}
    header{display:flex; align-items:center; gap:16px}
    .logo{width:72px; height:72px; border-radius:12px; display:flex; align-items:center; justify-content:center; background:linear-gradient(135deg,#001219 0%, #002b22 100%); box-shadow: 0 6px 18px rgba(0,0,0,0.6); border:1px solid rgba(255,255,255,0.03)}
    .logo svg{filter: drop-shadow(0 8px 18px rgba(0,255,163,0.06));}
    h1{margin:0; font-size:22px; letter-spacing:0.6px}
    p.lead{margin:6px 0 0; color:var(--muted); font-size:13px}
    .grid{display:grid; grid-template-columns: 1fr 360px; gap:18px; margin-top:18px}
    .panel{background:var(--panel); padding:14px; border-radius:12px; border:1px solid var(--glass)}
    .controls{display:flex; flex-direction:column; gap:10px}
    label.file{display:block; background:linear-gradient(90deg, rgba(255,255,255,0.01), rgba(255,255,255,0.015)); padding:10px; border-radius:8px; border:1px dashed rgba(0,255,163,0.06); cursor:pointer; text-align:center}
    input[type=file]{display:none}
    .small{font-size:12px; color:var(--muted)}
    .buttons{display:flex; gap:12px; margin-top:12px}
    .btn{background:transparent; border:1px solid rgba(0,255,163,0.15); color:var(--accent); padding:10px 14px; border-radius:10px; cursor:pointer; font-weight:600}
    .btn.primary{background:linear-gradient(90deg, rgba(0,255,163,0.08), rgba(0,200,140,0.02)); box-shadow: 0 8px 30px rgba(0,255,163,0.03); border:1px solid rgba(0,255,163,0.22)}
    .btn.warn{border-color: rgba(255,100,100,0.18); color:#ffb3b3}
    .status{margin-top:12px; font-family:var(--mono); font-size:13px; color:var(--muted); white-space:pre-wrap}
    .preview{display:flex; flex-direction:column; gap:10px}
    .thumb{height:140px; border-radius:8px; background:linear-gradient(180deg,#081017,#031017); display:flex; align-items:center; justify-content:center; color:var(--muted); font-size:13px; overflow:hidden}
    footer{display:flex; justify-content:space-between; align-items:center; margin-top:14px; color:var(--muted); font-size:13px}
    .madeby{font-weight:600; color:var(--accent)}
    @media(max-width:880px){ .grid{grid-template-columns:1fr; } .logo{display:none} }
  </style>
</head>
<body>
  <div class="card" role="main">
    <header>
      <div class="logo" aria-hidden="true">
        <svg width="44" height="44" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M3 12h18" stroke="url(#g)" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/>
          <rect x="5" y="7" width="14" height="8" rx="2" stroke="url(#g)" stroke-width="1.2"/>
          <defs>
            <linearGradient id="g" x1="0" x2="1" y1="0" y2="1"><stop offset="0" stop-color="#00ffa3"/><stop offset="1" stop-color="#00c28a"/></linearGradient>
          </defs>
        </svg>
      </div>
      <div>
        <h1>RahasyaSetu</h1>
        <p class="lead">Client-side steganography — hide files inside images, audio, or video. Local-only, PoC.</p>
      </div>
    </header><div class="grid">
  <section class="panel">
    <div class="controls">
      <label class="file">Carrier (drop or click)
        <input id="carrierInput" type="file" />
        <div class="small">Any image/audio/video file. Tool will auto-detect and pick a method (LSB for PNG/WAV, append for lossy carriers).</div>
      </label>

      <label class="file">Payload (file to hide)
        <input id="payloadInput" type="file" />
        <div class="small">Any file type. The script checks carrier capacity and warns.</div>
      </label>

      <div class="buttons">
        <button id="hideBtn" class="btn primary">Hide</button>
        <button id="extractBtn" class="btn">Extract</button>
      </div>

      <div id="status" class="status">Ready. Choose carrier and payload, then click <b>Hide</b> or provide a stego file and click <b>Extract</b>.</div>
    </div>
  </section>

  <aside class="panel preview">
    <div class="thumb" id="thumb">No carrier selected</div>
    <div class="small">Output / Download link will appear here after operations. Files are processed locally — nothing is uploaded.</div>
    <div id="downloadArea"></div>
  </aside>
</div>

<footer>
  <div class="small">Made by <span class="madeby">Aryan Giri</span> — RahasyaSetu</div>
  <div class="small">Version 0.2 • Multi-carrier PoC</div>
</footer>

  </div><canvas id="workCanvas" style="display:none"></canvas>

<script>
// RahasyaSetu v0.2 — multi-carrier PoC
// Methods implemented here:
// - PNG LSB (canvas) — for lossless images
// - WAV LSB (PCM 16-bit) — for .wav audio
// - Append method (generic): append payload+header after EOF for lossy carriers (jpg, mp3, mp4, etc.) and extract by searching magic

const MAGIC = 'RAHASYA1'; // marker for appended and embedded payloads
const carrierInput = document.getElementById('carrierInput');
const payloadInput = document.getElementById('payloadInput');
const hideBtn = document.getElementById('hideBtn');
const extractBtn = document.getElementById('extractBtn');
const statusEl = document.getElementById('status');
const thumb = document.getElementById('thumb');
const downloadArea = document.getElementById('downloadArea');
const canvas = document.getElementById('workCanvas');

function setStatus(s){ statusEl.textContent = s; }
function fileToArrayBuffer(file){ return new Promise((res, rej)=>{ const fr = new FileReader(); fr.onload = ()=>res(fr.result); fr.onerror = rej; fr.readAsArrayBuffer(file); }); }
function arrayBufferToUint8(buf){ return new Uint8Array(buf); }
function concatUInt8Arrays(arrays){ let total = arrays.reduce((s,a)=>s+a.length,0); const out = new Uint8Array(total); let off=0; for(const a of arrays){ out.set(a, off); off+=a.length; } return out; }

// Utilities for header: MAGIC + 4 bytes payload length + 2 bytes filename len + filename bytes
function makeHeader(filename, payloadLen){ const fnameBytes = new TextEncoder().encode(filename); const header = new Uint8Array(MAGIC.length + 4 + 2 + fnameBytes.length);
  let off=0; for(let i=0;i<MAGIC.length;i++) header[off++]=MAGIC.charCodeAt(i);
  header[off++]= (payloadLen >>> 24) & 0xFF; header[off++]= (payloadLen >>> 16) & 0xFF; header[off++]= (payloadLen >>> 8) & 0xFF; header[off++]= (payloadLen) & 0xFF;
  header[off++]= (fnameBytes.length >>> 8) & 0xFF; header[off++]= fnameBytes.length & 0xFF;
  header.set(fnameBytes, off);
  return header;
}

function readHeaderFromBytes(bytes, offset){ // returns {payloadLen, filename, headerLen}
  const magicBytes = bytes.slice(offset, offset + MAGIC.length);
  let magic = ''; for(let i=0;i<MAGIC.length;i++) magic += String.fromCharCode(magicBytes[i]); if(magic !== MAGIC) return null;
  let idx = offset + MAGIC.length; const payloadLen = (bytes[idx]<<24) | (bytes[idx+1]<<16) | (bytes[idx+2]<<8) | (bytes[idx+3]); idx += 4; const fnLen = (bytes[idx]<<8) | (bytes[idx+1]); idx += 2; const fnameBytes = bytes.slice(idx, idx + fnLen); const filename = new TextDecoder().decode(fnameBytes); idx += fnLen; return {payloadLen, filename, headerLen: idx - offset}; }

// --- Append method (generic) ---
async function embedAppendMethod(carrierFile, payloadFile){ setStatus('Using generic append method (fast) — safe for lossy carriers.');
  const carrierBuf = await fileToArrayBuffer(carrierFile); const carrierBytes = arrayBufferToUint8(carrierBuf);
  const payloadBuf = await fileToArrayBuffer(payloadFile); const payloadBytes = arrayBufferToUint8(payloadBuf);
  const header = makeHeader(payloadFile.name, payloadBytes.length);
  const out = concatUInt8Arrays([carrierBytes, header, payloadBytes]);
  const blob = new Blob([out], {type: carrierFile.type || 'application/octet-stream'});
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = carrierFile.name.replace(/(\.[^.]*)?$/, '_stego$1'); a.textContent = 'Download stego (append)'; a.style.display='inline-block'; downloadArea.innerHTML=''; downloadArea.appendChild(a); setStatus('Done — appended payload. Extraction scans for marker at file end.');
}

// --- Extract append method ---
async function extractAppendMethod(carrierFile){ setStatus('Scanning for appended payload marker...'); const carrierBuf = await fileToArrayBuffer(carrierFile); const bytes = arrayBufferToUint8(carrierBuf);
  // search from end for MAGIC (scan last ~2MB for efficiency). We'll scan entire file but backwards.
  const maxScan = Math.min(bytes.length, 5_000_000); const start = bytes.length - maxScan; let found = -1;
  for(let i = bytes.length - MAGIC.length; i >= Math.max(0, start); i--){ let ok = true; for(let j=0;j<MAGIC.length;j++){ if(bytes[i+j] !== MAGIC.charCodeAt(j)){ ok=false; break; } } if(ok){ found = i; break; } }
  if(found === -1){ setStatus('No appended payload marker found.'); return; }
  const hdr = readHeaderFromBytes(bytes, found);
  if(!hdr){ setStatus('Header parse failed.'); return; }
  const payloadStart = found + hdr.headerLen; const payloadEnd = payloadStart + hdr.payloadLen; if(payloadEnd > bytes.length){ setStatus('File seems truncated or header is corrupted.'); return; }
  const payloadBytes = bytes.slice(payloadStart, payloadEnd); const blob = new Blob([payloadBytes]); const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = hdr.filename || 'extracted_payload'; a.textContent = 'Download extracted payload'; a.style.display='inline-block'; downloadArea.innerHTML=''; downloadArea.appendChild(a); setStatus(`Extracted ${hdr.payloadLen} bytes as "${a.download}" from appended payload.`);
}

// --- PNG LSB (kept from previous PoC) ---
function bitsFromUint8Array(arr){ const bits = []; for(let i=0;i<arr.length;i++){ for(let b=7;b>=0;b--) bits.push( (arr[i]>>>b) & 1 ); } return bits; }
function bitsToUint8Array(bits){ const bytes = new Uint8Array(Math.ceil(bits.length/8)); for(let i=0;i<bytes.length;i++){ let v=0; for(let b=0;b<8;b++){ const bit = bits[i*8 + b] || 0; v = (v<<1) | bit; } bytes[i]=v; } return bytes; }

async function embedPNGLSB(carrierFile, payloadFile){ setStatus('Using PNG LSB method (lossless images).'); await loadImageToCanvas(carrierFile); const ctx = canvas.getContext('2d'); const imgData = ctx.getImageData(0,0,canvas.width,canvas.height); const pixels = imgData.data;
  const payloadBuf = await fileToArrayBuffer(payloadFile); const p8 = new Uint8Array(payloadBuf); const header = makeHeader(payloadFile.name, p8.length);
  const container = concatUInt8Arrays([header, p8]); const bits = bitsFromUint8Array(container);
  const capacityBits = (pixels.length/4)*3; if(bits.length + 16 > capacityBits){ setStatus('Payload too large for this image. Choose larger carrier or smaller payload.'); return; }
  let bitIndex=0; for(let px=0; px<pixels.length; px+=4){ if(bitIndex < bits.length) pixels[px] = (pixels[px] & 0xFE) | bits[bitIndex++]; else break; if(bitIndex < bits.length) pixels[px+1] = (pixels[px+1] & 0xFE) | bits[bitIndex++]; else break; if(bitIndex < bits.length) pixels[px+2] = (pixels[px+2] & 0xFE) | bits[bitIndex++]; else break; }
  ctx.putImageData(imgData,0,0);
  canvas.toBlob((blob)=>{ downloadArea.innerHTML=''; const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = carrierFile.name.replace(/(\.[^.]*)?$/, '_stego.png'); a.textContent = 'Download stego PNG (LSB)'; a.style.display='inline-block'; downloadArea.appendChild(a); setStatus('Done — stego PNG created.'); }, 'image/png'); }

async function extractPNGLSB(carrierFile){ setStatus('Extracting from PNG LSB...'); await loadImageToCanvas(carrierFile); const ctx = canvas.getContext('2d'); const imgData = ctx.getImageData(0,0,canvas.width,canvas.height); const pixels = imgData.data; const bits = [];
  for(let px=0; px<pixels.length; px+=4){ bits.push(pixels[px]&1); bits.push(pixels[px+1]&1); bits.push(pixels[px+2]&1); }
  // read MAGIC
  let magicStr=''; for(let i=0;i<MAGIC.length;i++){ let val=0; for(let b=0;b<8;b++){ val = (val<<1) | bits[i*8 + b]; } magicStr += String.fromCharCode(val); }
  if(magicStr !== MAGIC){ setStatus('No embedded data (PNG LSB magic mismatch).'); return; }
  const sizeStart = MAGIC.length*8; let payloadSize=0; for(let i=0;i<32;i++) payloadSize = (payloadSize<<1) | bits[sizeStart + i]; const fnLenStart = sizeStart + 32; let fnLen=0; for(let i=0;i<16;i++) fnLen = (fnLen<<1) | bits[fnLenStart + i]; const fnStart = fnLenStart + 16; const filenameBytes = new Uint8Array(fnLen);
  for(let i=0;i<fnLen;i++){ let byte=0; for(let b=0;b<8;b++){ byte = (byte<<1) | bits[fnStart + i*8 + b]; } filenameBytes[i]=byte; }
  const filename = new TextDecoder().decode(filenameBytes); const payloadStart = fnStart + fnLen*8; const payloadBytes = new Uint8Array(payloadSize);
  for(let i=0;i<payloadSize;i++){ let byte=0; for(let b=0;b<8;b++){ byte = (byte<<1) | bits[payloadStart + i*8 + b]; } payloadBytes[i]=byte; }
  const blob = new Blob([payloadBytes]); downloadArea.innerHTML=''; const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = filename || 'extracted_payload'; a.textContent = 'Download extracted payload'; a.style.display='inline-block'; downloadArea.appendChild(a); setStatus(`Extracted ${payloadSize} bytes as "${a.download}".`);
}

// --- WAV LSB (simple 16-bit PCM implementation) ---
function parseWAVHeader(bytes){ // returns {dataOffset, dataLen, sampleBits, channels}
  // minimal RIFF WAVE parser to find 'data' chunk
  if(bytes.length < 44) return null; if(String.fromCharCode(...bytes.slice(0,4)) !== 'RIFF') return null; if(String.fromCharCode(...bytes.slice(8,12)) !== 'WAVE') return null;
  let idx = 12; let dataOffset = -1; let dataLen = 0; let audioFormat=1; let bitsPerSample=16; let channels=1;
  while(idx + 8 <= bytes.length){ const chunkId = String.fromCharCode(...bytes.slice(idx, idx+4)); const chunkSize = bytes[idx+4] | (bytes[idx+5]<<8) | (bytes[idx+6]<<16) | (bytes[idx+7]<<24); idx += 8;
    if(chunkId === 'fmt '){ audioFormat = bytes[idx] | (bytes[idx+1]<<8); channels = bytes[idx+2] | (bytes[idx+3]<<8); bitsPerSample = bytes[idx+14] | (bytes[idx+15]<<8); }
    else if(chunkId === 'data'){ dataOffset = idx; dataLen = chunkSize; break; }
    idx += chunkSize + (chunkSize%2); }
  if(dataOffset === -1) return null; return {dataOffset, dataLen, bitsPerSample, channels, audioFormat}; }

async function embedWAVLSB(carrierFile, payloadFile){ setStatus('Using WAV LSB method (requires 16-bit PCM).'); const carrierBuf = await fileToArrayBuffer(carrierFile); const bytes = arrayBufferToUint8(carrierBuf); const header = parseWAVHeader(bytes); if(!header){ setStatus('Not a valid WAV or unsupported format.'); return; }
  if(header.bitsPerSample !== 16){ setStatus('Only 16-bit PCM WAV supported in this PoC.'); return; }
  const payloadBuf = await fileToArrayBuffer(payloadFile); const p8 = new Uint8Array(payloadBuf); const hdr = makeHeader(payloadFile.name, p8.length); const container = concatUInt8Arrays([hdr, p8]); const bits = bitsFromUint8Array(container);
  const sampleCount = header.dataLen / 2; const capacityBits = sampleCount; if(bits.length > capacityBits){ setStatus(`Payload too large for WAV. Capacity (bits)=${capacityBits}, needed=${bits.length}.`); return; }
  // embed into LSB of samples (little-endian 16-bit)
  let bitIndex = 0; for(let i=0;i<sampleCount;i++){ if(bitIndex >= bits.length) break; const bytePos = header.dataOffset + i*2; let sample = bytes[bytePos] | (bytes[bytePos+1]<<8); // signed? but we just modify LSB
    sample = (sample & 0xFFFE) | bits[bitIndex++]; bytes[bytePos] = sample & 0xFF; bytes[bytePos+1] = (sample >>> 8) & 0xFF; }
  const blob = new Blob([bytes], {type: carrierFile.type || 'audio/wav'}); downloadArea.innerHTML=''; const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = carrierFile.name.replace(/(\.[^.]*)?$/, '_stego.wav'); a.textContent = 'Download stego WAV (LSB)'; a.style.display='inline-block'; downloadArea.appendChild(a); setStatus('Done — WAV stego created.'); }

async function extractWAVLSB(carrierFile){ setStatus('Extracting from WAV LSB...'); const carrierBuf = await fileToArrayBuffer(carrierFile); const bytes = arrayBufferToUint8(carrierBuf); const header = parseWAVHeader(bytes); if(!header){ setStatus('Not a valid WAV or unsupported format.'); return; }
  if(header.bitsPerSample !== 16){ setStatus('Only 16-bit PCM WAV supported in this PoC.'); return; }
  const sampleCount = header.dataLen / 2; const bits = [];
  for(let i=0;i<sampleCount;i++){ const bytePos = header.dataOffset + i*2; const sample = bytes[bytePos] | (bytes[bytePos+1]<<8); bits.push(sample & 1); }
  // read MAGIC
  let magicStr=''; for(let i=0;i<MAGIC.length;i++){ let val=0; for(let b=0;b<8;b++){ val = (val<<1) | bits[i*8 + b]; } magicStr += String.fromCharCode(val); }
  if(magicStr !== MAGIC){ setStatus('No embedded data (WAV LSB magic mismatch).'); return; }
  const sizeStart = MAGIC.length*8; let payloadSize=0; for(let i=0;i<32;i++) payloadSize = (payloadSize<<1) | bits[sizeStart + i]; const fnLenStart = sizeStart + 32; let fnLen=0; for(let i=0;i<16;i++) fnLen = (fnLen<<1) | bits[fnLenStart + i]; const fnStart = fnLenStart + 16; const filenameBytes = new Uint8Array(fnLen);
  for(let i=0;i<fnLen;i++){ let byte=0; for(let b=0;b<8;b++){ byte = (byte<<1) | bits[fnStart + i*8 + b]; } filenameBytes[i]=byte; }
  const filename = new TextDecoder().decode(filenameBytes); const payloadStart = fnStart + fnLen*8; const payloadBytes = new Uint8Array(payloadSize);
  for(let i=0;i<payloadSize;i++){ let byte=0; for(let b=0;b<8;b++){ byte = (byte<<1) | bits[payloadStart + i*8 + b]; } payloadBytes[i]=byte; }
  const blob = new Blob([payloadBytes]); downloadArea.innerHTML=''; const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = filename || 'extracted_payload'; a.textContent = 'Download extracted payload'; a.style.display='inline-block'; downloadArea.appendChild(a); setStatus(`Extracted ${payloadSize} bytes as "${a.download}".`);
}

// --- Helper: load image to canvas (used by PNG LSB) ---
function loadImageToCanvas(file){ return new Promise((res, rej)=>{ const url = URL.createObjectURL(file); const img = new Image(); img.onload = ()=>{ canvas.width = img.naturalWidth; canvas.height = img.naturalHeight; const ctx = canvas.getContext('2d'); ctx.drawImage(img,0,0); URL.revokeObjectURL(url); res(); }; img.onerror = (e)=>{ URL.revokeObjectURL(url); rej(e); }; img.src = url; }); }

// --- Auto-detect carrier type and pick method ---
function detectCarrierType(file){ const name = (file.name||'').toLowerCase(); const t = file.type || '';
  if(name.endsWith('.png') || t === 'image/png') return 'png';
  if(name.endsWith('.wav') || t === 'audio/wav' || t === 'audio/x-wav') return 'wav';
  // quick heuristics for common lossy containers: jpg/mp3/mp4 -> use append
  if(name.endsWith('.jpg')||name.endsWith('.jpeg')||t.startsWith('image/')) return 'append';
  if(name.endsWith('.mp3')||t.startsWith('audio/')) return 'append';
  if(name.endsWith('.mp4')||name.endsWith('.mov')||t.startsWith('video/')) return 'append';
  return 'append'; }

// --- UI bindings & actions ---
carrierInput.addEventListener('change', ()=>{ show
